# Project 10: Compilation

## Implementation Details

We propose implementing the project in two stages. First, write and test
the JackTokenizer module. Next, write and test the CompilationEngine
module, which implements the parser described in the chapter.

### Stage I: JackTokenizer

Tokenizing, a basic service of any syntax analyzer, is the act of
breaking a given textual input into a stream of tokens. And while it is
at it, the tokenizer can also classify the tokens into lexical
categories. With that in mind, your first task it to implement, and test,
the JackTokenizer module. Specifically, you have to develop:

1. A Tokenizer implementation, and
2. a test program that goes through a given .jack input file.

#### Tokenizer Testing

Test your tokenizer on the Square Dance and the TestArray programs.

- Apply your tokenizer test to each Xxx.jack source file of the relevant test.
- Given an Xxx.jack source file, have your tokenizer give the output file
  the name XxxT.xml, and then iterate on every token of the source file like so:
- Each token should be printed in a separate line, along with its
  classification: symbol, keyword, identifier, integer constant or string
  constant.
- Use the supplied TextComparer utility to compare the generated output
  to the supplied .xml compare files.
- Since the output files generated by your tokenizer test will have the
  same names and extensions as those of the supplied compare files, we
  suggest putting them in separate directories.

### Stage II: Parser (CompilationEngine)

In the context of this project, parsing is defined narrowly as the act of
going over the tokenized input and rendering its grammatical structure
using some agreed-upon format. The specific parser that we implement here
is based on the Jack grammar, and is designed to emit XML output. Both
the grammar and the agreed-upon XML tags are described in chapter 10.

The Jack parser is implemented by the CompilationEngine module. Your task
is to implement this API: write each one of the specified methods, and
make sure that it emits the correct XML output. For the benefit of
unit-testing, we recommend to begin by:

1. First, write a compilation engine that handles any given Jack code except
   for expressions;
2. Next, extend the compilation engine to handle expressions as well.

The test programs supplied are designed to support this staged strategy.

#### Parser Testing

- Apply your syntax analyzer to the supplied test programs, then use the
  supplied TextComparer utility to compare the generated output to the
  supplied .xml compare files.
- Since the output files generated by your syntax analyzer will have the
  same names and extensions as those of the supplied compare files, we
  suggest putting them in separate directories.
- Note that the indentation of the XML output is only for readability.
  Web browsers and the supplied TextComparer ignore white space.

## Submission Template

- JackAnalyzer: The executable for the project. This allows our graders to run
  your project in a standard manner on UNIX-like operating systems.
- Makefile: A makefile for the project. This allows our graders to prepare your
  project for execution in a standard manner on UNIX-like operating systems.
- JackAnalyzer.py: The project's main .py file.
- JackTokenizer.py: Tokenizes an input .jack file according to Jack's grammar.
- CompilationEngine.py: Gets input from a JackTokenizer and emits its parsed
  structure into an output stream.

## Tools

If you are wondering whether some Jack program is valid or not, you should
use the built-in JackCompiler to compile it; if compilation fails, it is
invalid. Otherwise, it is valid.

If you want, you can compile the supplied SquareDance and TestArray
programs using the supplied ("built-in") JackCompiler, then use the
supplied VM emulator to run the compiled code. This shows that the
test programs are not just plain text; they also have semantics, or
meaning, something that the syntax analyzer does not care about.

For more information about our built-in tools, see the tutorials in the
lectures and submission page, and additional information provided in
tools/README.md.

## What To Submit

- You can change the template however you want, or even not use it at all.
  But, your project should use the same standard installation and running
  procedures, and standard inputs that the template uses.
- You should submit a zip file with the following files:
  A run-file named “JackAnalyzer”, a Makefile called “Makefile”, an AUTHORS file,
  and the source code for your implementation.
- The submission should not contain any folder.
- The AUTHORS file must contain the following:
  - In the first line: login(s) of the author(s), separated by commas and
    nothing else! If you work alone, do not include a comma.
    Logins should be identical to the names of your home folders and are
    case-sensitive.
  - Name(s), email(s) and ID(s) of the project's author(s).
  - Any remarks you have about your submission.

## License

This file is part of nand2tetris, as taught in The Hebrew University, and
was written by Aviv Yaish. It is an extension to the specifications given
[here](https://www.nand2tetris.org) (Shimon Schocken and Noam Nisan, 2017),
as allowed by the Creative Common Attribution-NonCommercial-ShareAlike 3.0
Unported [License](https://creativecommons.org/licenses/by-nc-sa/3.0/).
